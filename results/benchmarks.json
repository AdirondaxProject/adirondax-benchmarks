{
    "bench_inverse_problem.InverseProblemSuite.peakmem_forward_model": {
        "code": "class InverseProblemSuite:\n    def peakmem_forward_model(self):\n        self.run_forward_model()\n\n    def setup(self):\n        file_path = os.path.join(os.path.dirname(__file__), \"target.png\")\n        target_data = img.imread(file_path)[:, :, 0]\n        self.rho_target = jnp.flipud(jnp.array(target_data, dtype=float))\n        self.rho_target = 1.0 - 0.5 * (self.rho_target - 0.5)\n        self.rho_target /= jnp.mean(self.rho_target)\n    \n        n = 128\n        nt = 100\n        t_stop = 0.03\n        self.params = {\n            \"physics\": {\n                \"quantum\": True,\n                \"gravity\": True,\n            },\n            \"mesh\": {\n                \"type\": \"cartesian\",\n                \"resolution\": [n, n],\n                \"box_size\": [1.0, 1.0],\n            },\n            \"time\": {\n                \"span\": t_stop,\n                \"num_timesteps\": nt,\n            },\n        }",
        "name": "bench_inverse_problem.InverseProblemSuite.peakmem_forward_model",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "1e2fadd925e5a59f800c92e75a214a90660dd1ab9be3f34530144becb3920f3b"
    },
    "bench_inverse_problem.InverseProblemSuite.peakmem_inverse_problem": {
        "code": "class InverseProblemSuite:\n    def peakmem_inverse_problem(self):\n        self.solve_inverse_problem()\n\n    def setup(self):\n        file_path = os.path.join(os.path.dirname(__file__), \"target.png\")\n        target_data = img.imread(file_path)[:, :, 0]\n        self.rho_target = jnp.flipud(jnp.array(target_data, dtype=float))\n        self.rho_target = 1.0 - 0.5 * (self.rho_target - 0.5)\n        self.rho_target /= jnp.mean(self.rho_target)\n    \n        n = 128\n        nt = 100\n        t_stop = 0.03\n        self.params = {\n            \"physics\": {\n                \"quantum\": True,\n                \"gravity\": True,\n            },\n            \"mesh\": {\n                \"type\": \"cartesian\",\n                \"resolution\": [n, n],\n                \"box_size\": [1.0, 1.0],\n            },\n            \"time\": {\n                \"span\": t_stop,\n                \"num_timesteps\": nt,\n            },\n        }",
        "name": "bench_inverse_problem.InverseProblemSuite.peakmem_inverse_problem",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "372428244dcff5e16e2b3c3a7947558e0fd31bbfcea0004697d226a4b09a9cef"
    },
    "bench_inverse_problem.InverseProblemSuite.time_forward_model": {
        "code": "class InverseProblemSuite:\n    def time_forward_model(self):\n        self.run_forward_model()\n\n    def setup(self):\n        file_path = os.path.join(os.path.dirname(__file__), \"target.png\")\n        target_data = img.imread(file_path)[:, :, 0]\n        self.rho_target = jnp.flipud(jnp.array(target_data, dtype=float))\n        self.rho_target = 1.0 - 0.5 * (self.rho_target - 0.5)\n        self.rho_target /= jnp.mean(self.rho_target)\n    \n        n = 128\n        nt = 100\n        t_stop = 0.03\n        self.params = {\n            \"physics\": {\n                \"quantum\": True,\n                \"gravity\": True,\n            },\n            \"mesh\": {\n                \"type\": \"cartesian\",\n                \"resolution\": [n, n],\n                \"box_size\": [1.0, 1.0],\n            },\n            \"time\": {\n                \"span\": t_stop,\n                \"num_timesteps\": nt,\n            },\n        }",
        "min_run_count": 2,
        "name": "bench_inverse_problem.InverseProblemSuite.time_forward_model",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "513a282a924b5d3cc05ca027694e2758082a787d9149413cbef939b4ac79480d",
        "warmup_time": -1
    },
    "bench_inverse_problem.InverseProblemSuite.time_inverse_problem": {
        "code": "class InverseProblemSuite:\n    def time_inverse_problem(self):\n        self.solve_inverse_problem()\n\n    def setup(self):\n        file_path = os.path.join(os.path.dirname(__file__), \"target.png\")\n        target_data = img.imread(file_path)[:, :, 0]\n        self.rho_target = jnp.flipud(jnp.array(target_data, dtype=float))\n        self.rho_target = 1.0 - 0.5 * (self.rho_target - 0.5)\n        self.rho_target /= jnp.mean(self.rho_target)\n    \n        n = 128\n        nt = 100\n        t_stop = 0.03\n        self.params = {\n            \"physics\": {\n                \"quantum\": True,\n                \"gravity\": True,\n            },\n            \"mesh\": {\n                \"type\": \"cartesian\",\n                \"resolution\": [n, n],\n                \"box_size\": [1.0, 1.0],\n            },\n            \"time\": {\n                \"span\": t_stop,\n                \"num_timesteps\": nt,\n            },\n        }",
        "min_run_count": 2,
        "name": "bench_inverse_problem.InverseProblemSuite.time_inverse_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f28b80c4ba92cd5fd2c9e8a046fdffaa7d9e7a7ae7a5a471d21430921a86d5c0",
        "warmup_time": -1
    },
    "bench_mhd.MHDSuite.peakmem_run_sim": {
        "code": "class MHDSuite:\n    def peakmem_run_sim(self):\n        self.run_sim()\n\n    def setup(self):\n        n = 512\n        nt = int(n / 16)\n        t_stop = 0.01\n    \n        self.params = {\n            \"physics\": {\n                \"hydro\": True,\n                \"magnetic\": True,\n            },\n            \"mesh\": {\n                \"type\": \"cartesian\",\n                \"resolution\": [n, n],\n                \"box_size\": [1.0, 1.0],\n            },\n            \"time\": {\n                \"span\": t_stop,\n                \"num_timesteps\": nt,\n            },\n            \"hydro\": {\n                \"eos\": {\"type\": \"ideal\", \"gamma\": 5.0 / 3.0},\n                \"riemann_solver\": \"hlld\",\n                \"slope_limiting\": True,\n            },\n        }",
        "name": "bench_mhd.MHDSuite.peakmem_run_sim",
        "param_names": [],
        "params": [],
        "type": "peakmemory",
        "unit": "bytes",
        "version": "55cdfe053378b9df453c9a27ade236009955a6cdee1a0b337b16aa54f6345c81"
    },
    "bench_mhd.MHDSuite.time_run_sim": {
        "code": "class MHDSuite:\n    def time_run_sim(self):\n        self.run_sim()\n\n    def setup(self):\n        n = 512\n        nt = int(n / 16)\n        t_stop = 0.01\n    \n        self.params = {\n            \"physics\": {\n                \"hydro\": True,\n                \"magnetic\": True,\n            },\n            \"mesh\": {\n                \"type\": \"cartesian\",\n                \"resolution\": [n, n],\n                \"box_size\": [1.0, 1.0],\n            },\n            \"time\": {\n                \"span\": t_stop,\n                \"num_timesteps\": nt,\n            },\n            \"hydro\": {\n                \"eos\": {\"type\": \"ideal\", \"gamma\": 5.0 / 3.0},\n                \"riemann_solver\": \"hlld\",\n                \"slope_limiting\": True,\n            },\n        }",
        "min_run_count": 2,
        "name": "bench_mhd.MHDSuite.time_run_sim",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "66011741d0add602344eea1e13273caaa2f1095d4e4758f4e275074d740aceb2",
        "warmup_time": -1
    },
    "version": 2
}